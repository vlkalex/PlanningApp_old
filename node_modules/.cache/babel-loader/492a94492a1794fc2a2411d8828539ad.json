{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.coordinateToTimeRatio = coordinateToTimeRatio;\nexports.calculateXPositionForTime = calculateXPositionForTime;\nexports.calculateTimeForXPosition = calculateTimeForXPosition;\nexports.iterateTimes = iterateTimes;\nexports.getMinUnit = getMinUnit;\nexports.getNextUnit = getNextUnit;\nexports.calculateInteractionNewTimes = calculateInteractionNewTimes;\nexports.calculateDimensions = calculateDimensions;\nexports.getGroupOrders = getGroupOrders;\nexports.getGroupedItems = getGroupedItems;\nexports.getVisibleItems = getVisibleItems;\nexports.collision = collision;\nexports.groupStack = groupStack;\nexports.groupNoStack = groupNoStack;\nexports.stackAll = stackAll;\nexports.stackGroup = stackGroup;\nexports.stackTimelineItems = stackTimelineItems;\nexports.getCanvasWidth = getCanvasWidth;\nexports.getItemDimensions = getItemDimensions;\nexports.getItemWithInteractions = getItemWithInteractions;\nexports.getCanvasBoundariesFromVisibleTime = getCanvasBoundariesFromVisibleTime;\nexports.calculateScrollCanvas = calculateScrollCanvas;\nexports.minCellWidth = void 0;\n\nvar _moment = _interopRequireDefault(require(\"moment\"));\n\nvar _generic = require(\"./generic\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    if (i % 2) {\n      var source = arguments[i] != null ? arguments[i] : {};\n      var ownKeys = Object.keys(source);\n\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }));\n      }\n\n      ownKeys.forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i]));\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n/**\n * Calculate the ms / pixel ratio of the timeline state\n * @param {number} canvasTimeStart\n * @param {number} canvasTimeEnd\n * @param {number} canvasWidth\n * @returns {number}\n */\n\n\nfunction coordinateToTimeRatio(canvasTimeStart, canvasTimeEnd, canvasWidth) {\n  return (canvasTimeEnd - canvasTimeStart) / canvasWidth;\n}\n/**\n * For a given time, calculate the pixel position given timeline state\n * (timeline width in px, canvas time range)\n * @param {number} canvasTimeStart\n * @param {number} canvasTimeEnd\n * @param {number} canvasWidth\n * @param {number} time\n * @returns {number}\n */\n\n\nfunction calculateXPositionForTime(canvasTimeStart, canvasTimeEnd, canvasWidth, time) {\n  var widthToZoomRatio = canvasWidth / (canvasTimeEnd - canvasTimeStart);\n  var timeOffset = time - canvasTimeStart;\n  return timeOffset * widthToZoomRatio;\n}\n/**\n * For a given x position (leftOffset) in pixels, calculate time based on\n * timeline state (timeline width in px, canvas time range)\n * @param {number} canvasTimeStart\n * @param {number} canvasTimeEnd\n * @param {number} canvasWidth\n * @param {number} leftOffset\n * @returns {number}\n */\n\n\nfunction calculateTimeForXPosition(canvasTimeStart, canvasTimeEnd, canvasWidth, leftOffset) {\n  var timeToPxRatio = (canvasTimeEnd - canvasTimeStart) / canvasWidth;\n  var timeFromCanvasTimeStart = timeToPxRatio * leftOffset;\n  return timeFromCanvasTimeStart + canvasTimeStart;\n}\n\nfunction iterateTimes(start, end, unit, timeSteps, callback) {\n  var time = (0, _moment[\"default\"])(start).startOf(unit);\n\n  if (timeSteps[unit] && timeSteps[unit] > 1) {\n    var value = time.get(unit);\n    time.set(unit, value - value % timeSteps[unit]);\n  }\n\n  while (time.valueOf() < end) {\n    var nextTime = (0, _moment[\"default\"])(time).add(timeSteps[unit] || 1, \"\".concat(unit, \"s\"));\n    callback(time, nextTime);\n    time = nextTime;\n  }\n} // this function is VERY HOT as its used in Timeline.js render function\n// TODO: check if there are performance implications here\n// when \"weeks\" feature is implemented, this function will be modified heavily\n\n/** determine the current rendered time unit based on timeline time span\n *\n * zoom: (in milliseconds) difference between time start and time end of timeline canvas\n * width: (in pixels) pixel width of timeline canvas\n * timeSteps: map of timeDividers with number to indicate step of each divider\n */\n// the smallest cell we want to render is 17px\n// this can be manipulated to make the breakpoints change more/less\n// i.e. on zoom how often do we switch to the next unit of time\n// i think this is the distance between cell lines\n\n\nvar minCellWidth = 17;\nexports.minCellWidth = minCellWidth;\n\nfunction getMinUnit(zoom, width, timeSteps) {\n  // for supporting weeks, its important to remember that each of these\n  // units has a natural progression to the other. i.e. a year is 12 months\n  // a month is 24 days, a day is 24 hours.\n  // with weeks this isnt the case so weeks needs to be handled specially\n  var timeDividers = {\n    second: 1000,\n    minute: 60,\n    hour: 60,\n    day: 24,\n    month: 30,\n    year: 12\n  };\n  var minUnit = 'year'; // this timespan is in ms initially\n\n  var nextTimeSpanInUnitContext = zoom;\n  Object.keys(timeDividers).some(function (unit) {\n    // converts previous time span to current unit\n    // (e.g. milliseconds to seconds, seconds to minutes, etc)\n    nextTimeSpanInUnitContext = nextTimeSpanInUnitContext / timeDividers[unit]; // timeSteps is \"\n    // With what step to display different units. E.g. 15 for minute means only minutes 0, 15, 30 and 45 will be shown.\"\n    // how many cells would be rendered given this time span, for this unit?\n    // e.g. for time span of 60 minutes, and time step of 1, we would render 60 cells\n\n    var cellsToBeRenderedForCurrentUnit = nextTimeSpanInUnitContext / timeSteps[unit]; // what is happening here? why 3 if time steps are greater than 1??\n\n    var cellWidthToUse = timeSteps[unit] && timeSteps[unit] > 1 ? 3 * minCellWidth : minCellWidth; // for the minWidth of a cell, how many cells would be rendered given\n    // the current pixel width\n    // i.e. f\n\n    var minimumCellsToRenderUnit = width / cellWidthToUse;\n\n    if (cellsToBeRenderedForCurrentUnit < minimumCellsToRenderUnit) {\n      // for the current zoom, the number of cells we'd need to render all parts of this unit\n      // is less than the minimum number of cells needed at minimum cell width\n      minUnit = unit;\n      return true;\n    }\n  });\n  return minUnit;\n}\n\nfunction getNextUnit(unit) {\n  var nextUnits = {\n    second: 'minute',\n    minute: 'hour',\n    hour: 'day',\n    day: 'month',\n    month: 'year',\n    year: 'year'\n  };\n\n  if (!nextUnits[unit]) {\n    throw new Error(\"unit \".concat(unit, \" in not acceptable\"));\n  }\n\n  return nextUnits[unit];\n}\n/**\n * get the new start and new end time of item that is being\n * dragged or resized\n * @param {*} itemTimeStart original item time in milliseconds\n * @param {*} itemTimeEnd original item time in milliseconds\n * @param {*} dragTime new start time if item is dragged in milliseconds\n * @param {*} isDragging is item being dragged\n * @param {*} isResizing is item being resized\n * @param {`right` or `left`} resizingEdge resize edge\n * @param {*} resizeTime new resize time in milliseconds\n */\n\n\nfunction calculateInteractionNewTimes(_ref) {\n  var itemTimeStart = _ref.itemTimeStart,\n      itemTimeEnd = _ref.itemTimeEnd,\n      dragTime = _ref.dragTime,\n      isDragging = _ref.isDragging,\n      isResizing = _ref.isResizing,\n      resizingEdge = _ref.resizingEdge,\n      resizeTime = _ref.resizeTime;\n  var originalItemRange = itemTimeEnd - itemTimeStart;\n  var itemStart = isResizing && resizingEdge === 'left' ? resizeTime : itemTimeStart;\n  var itemEnd = isResizing && resizingEdge === 'right' ? resizeTime : itemTimeEnd;\n  return [isDragging ? dragTime : itemStart, isDragging ? dragTime + originalItemRange : itemEnd];\n}\n\nfunction calculateDimensions(_ref2) {\n  var itemTimeStart = _ref2.itemTimeStart,\n      itemTimeEnd = _ref2.itemTimeEnd,\n      canvasTimeStart = _ref2.canvasTimeStart,\n      canvasTimeEnd = _ref2.canvasTimeEnd,\n      canvasWidth = _ref2.canvasWidth;\n  var itemTimeRange = itemTimeEnd - itemTimeStart; // restrict startTime and endTime to be bounded by canvasTimeStart and canvasTimeEnd\n\n  var effectiveStartTime = Math.max(itemTimeStart, canvasTimeStart);\n  var effectiveEndTime = Math.min(itemTimeEnd, canvasTimeEnd);\n  var left = calculateXPositionForTime(canvasTimeStart, canvasTimeEnd, canvasWidth, effectiveStartTime);\n  var right = calculateXPositionForTime(canvasTimeStart, canvasTimeEnd, canvasWidth, effectiveEndTime);\n  var itemWidth = right - left;\n  var dimensions = {\n    left: left,\n    width: Math.max(itemWidth, 3),\n    collisionLeft: itemTimeStart,\n    collisionWidth: itemTimeRange\n  };\n  return dimensions;\n}\n/**\n * Get the order of groups based on their keys\n * @param {*} groups array of groups\n * @param {*} keys the keys object\n * @returns Ordered hash of objects with their array index and group\n */\n\n\nfunction getGroupOrders(groups, keys) {\n  var groupIdKey = keys.groupIdKey;\n  var groupOrders = {};\n\n  for (var i = 0; i < groups.length; i++) {\n    groupOrders[(0, _generic._get)(groups[i], groupIdKey)] = {\n      index: i,\n      group: groups[i]\n    };\n  }\n\n  return groupOrders;\n}\n/**\n * Adds items relevant to each group to the result of getGroupOrders\n * @param {*} items list of all items\n * @param {*} groupOrders the result of getGroupOrders\n */\n\n\nfunction getGroupedItems(items, groupOrders) {\n  var groupedItems = {};\n  var keys = Object.keys(groupOrders); // Initialize with result object for each group\n\n  for (var i = 0; i < keys.length; i++) {\n    var groupOrder = groupOrders[keys[i]];\n    groupedItems[i] = {\n      index: groupOrder.index,\n      group: groupOrder.group,\n      items: []\n    };\n  } // Populate groups\n\n\n  for (var _i = 0; _i < items.length; _i++) {\n    if (items[_i].dimensions.order !== undefined) {\n      var groupItem = groupedItems[items[_i].dimensions.order.index];\n\n      if (groupItem) {\n        groupItem.items.push(items[_i]);\n      }\n    }\n  }\n\n  return groupedItems;\n}\n\nfunction getVisibleItems(items, canvasTimeStart, canvasTimeEnd, keys) {\n  var itemTimeStartKey = keys.itemTimeStartKey,\n      itemTimeEndKey = keys.itemTimeEndKey;\n  return items.filter(function (item) {\n    return (0, _generic._get)(item, itemTimeStartKey) <= canvasTimeEnd && (0, _generic._get)(item, itemTimeEndKey) >= canvasTimeStart;\n  });\n}\n\nvar EPSILON = 0.001;\n\nfunction collision(a, b, lineHeight) {\n  var collisionPadding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : EPSILON; // 2d collisions detection - https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection\n\n  var verticalMargin = 0;\n  return a.collisionLeft + collisionPadding < b.collisionLeft + b.collisionWidth && a.collisionLeft + a.collisionWidth - collisionPadding > b.collisionLeft && a.top - verticalMargin + collisionPadding < b.top + b.height && a.top + a.height + verticalMargin - collisionPadding > b.top;\n}\n/**\n * Calculate the position of a given item for a group that\n * is being stacked\n */\n\n\nfunction groupStack(lineHeight, item, group, groupHeight, groupTop, itemIndex) {\n  // calculate non-overlapping positions\n  var curHeight = groupHeight;\n  var verticalMargin = (lineHeight - item.dimensions.height) / 2;\n\n  if (item.dimensions.stack && item.dimensions.top === null) {\n    item.dimensions.top = groupTop + verticalMargin;\n    curHeight = Math.max(curHeight, lineHeight);\n\n    do {\n      var collidingItem = null; //Items are placed from i=0 onwards, only check items with index < i\n\n      for (var j = itemIndex - 1, jj = 0; j >= jj; j--) {\n        var other = group[j];\n\n        if (other.dimensions.top !== null && other.dimensions.stack && collision(item.dimensions, other.dimensions, lineHeight)) {\n          collidingItem = other;\n          break;\n        } else {// console.log('dont test', other.top !== null, other !== item, other.stack);\n        }\n      }\n\n      if (collidingItem != null) {\n        // There is a collision. Reposition the items above the colliding element\n        item.dimensions.top = collidingItem.dimensions.top + lineHeight;\n        curHeight = Math.max(curHeight, item.dimensions.top + item.dimensions.height + verticalMargin - groupTop);\n      }\n    } while (collidingItem);\n  }\n\n  return {\n    groupHeight: curHeight,\n    verticalMargin: verticalMargin,\n    itemTop: item.dimensions.top\n  };\n} // Calculate the position of this item for a group that is not being stacked\n\n\nfunction groupNoStack(lineHeight, item, groupHeight, groupTop) {\n  var verticalMargin = (lineHeight - item.dimensions.height) / 2;\n\n  if (item.dimensions.top === null) {\n    item.dimensions.top = groupTop + verticalMargin;\n    groupHeight = Math.max(groupHeight, lineHeight);\n  }\n\n  return {\n    groupHeight: groupHeight,\n    verticalMargin: 0,\n    itemTop: item.dimensions.top\n  };\n}\n\nfunction sum() {\n  var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return arr.reduce(function (acc, i) {\n    return acc + i;\n  }, 0);\n}\n/**\n * Stack all groups\n * @param {*} items items to be stacked\n * @param {*} groupOrders the groupOrders object\n * @param {*} lineHeight\n * @param {*} stackItems should items be stacked?\n */\n\n\nfunction stackAll(itemsDimensions, groupOrders, lineHeight, stackItems) {\n  var groupHeights = [];\n  var groupTops = [];\n  var groupedItems = getGroupedItems(itemsDimensions, groupOrders);\n\n  for (var index in groupedItems) {\n    var groupItems = groupedItems[index];\n    var _itemsDimensions = groupItems.items,\n        group = groupItems.group;\n    var groupTop = sum(groupHeights); // Is group being stacked?\n\n    var isGroupStacked = group.stackItems !== undefined ? group.stackItems : stackItems;\n\n    var _stackGroup = stackGroup(_itemsDimensions, isGroupStacked, lineHeight, groupTop),\n        groupHeight = _stackGroup.groupHeight,\n        verticalMargin = _stackGroup.verticalMargin; // If group height is overridden, push new height\n    // Do this late as item position still needs to be calculated\n\n\n    groupTops.push(groupTop);\n\n    if (group.height) {\n      groupHeights.push(group.height);\n    } else {\n      groupHeights.push(Math.max(groupHeight, lineHeight));\n    }\n  }\n\n  return {\n    height: sum(groupHeights),\n    groupHeights: groupHeights,\n    groupTops: groupTops\n  };\n}\n/**\n * \n * @param {*} itemsDimensions \n * @param {*} isGroupStacked \n * @param {*} lineHeight \n * @param {*} groupTop \n */\n\n\nfunction stackGroup(itemsDimensions, isGroupStacked, lineHeight, groupTop) {\n  var groupHeight = 0;\n  var verticalMargin = 0; // Find positions for each item in group\n\n  for (var itemIndex = 0; itemIndex < itemsDimensions.length; itemIndex++) {\n    var r = {};\n\n    if (isGroupStacked) {\n      r = groupStack(lineHeight, itemsDimensions[itemIndex], itemsDimensions, groupHeight, groupTop, itemIndex);\n    } else {\n      r = groupNoStack(lineHeight, itemsDimensions[itemIndex], groupHeight, groupTop);\n    }\n\n    groupHeight = r.groupHeight;\n    verticalMargin = r.verticalMargin;\n  }\n\n  return {\n    groupHeight: groupHeight,\n    verticalMargin: verticalMargin\n  };\n}\n/**\n * Stack the items that will be visible\n * within the canvas area\n * @param {item[]} items\n * @param {group[]} groups\n * @param {number} canvasWidth\n * @param {number} canvasTimeStart\n * @param {number} canvasTimeEnd\n * @param {*} keys\n * @param {number} lineHeight\n * @param {number} itemHeightRatio\n * @param {boolean} stackItems\n * @param {*} draggingItem\n * @param {*} resizingItem\n * @param {number} dragTime\n * @param {left or right} resizingEdge\n * @param {number} resizeTime\n * @param {number} newGroupOrder\n */\n\n\nfunction stackTimelineItems(items, groups, canvasWidth, canvasTimeStart, canvasTimeEnd, keys, lineHeight, itemHeightRatio, stackItems, draggingItem, resizingItem, dragTime, resizingEdge, resizeTime, newGroupOrder) {\n  var visibleItems = getVisibleItems(items, canvasTimeStart, canvasTimeEnd, keys);\n  var visibleItemsWithInteraction = visibleItems.map(function (item) {\n    return getItemWithInteractions({\n      item: item,\n      keys: keys,\n      draggingItem: draggingItem,\n      resizingItem: resizingItem,\n      dragTime: dragTime,\n      resizingEdge: resizingEdge,\n      resizeTime: resizeTime,\n      groups: groups,\n      newGroupOrder: newGroupOrder\n    });\n  }); // if there are no groups return an empty array of dimensions\n\n  if (groups.length === 0) {\n    return {\n      dimensionItems: [],\n      height: 0,\n      groupHeights: [],\n      groupTops: []\n    };\n  } // Get the order of groups based on their id key\n\n\n  var groupOrders = getGroupOrders(groups, keys);\n  var dimensionItems = visibleItemsWithInteraction.map(function (item) {\n    return getItemDimensions({\n      item: item,\n      keys: keys,\n      canvasTimeStart: canvasTimeStart,\n      canvasTimeEnd: canvasTimeEnd,\n      canvasWidth: canvasWidth,\n      groupOrders: groupOrders,\n      lineHeight: lineHeight,\n      itemHeightRatio: itemHeightRatio\n    });\n  }).filter(function (item) {\n    return !!item;\n  }); // Get a new array of groupOrders holding the stacked items\n\n  var _stackAll = stackAll(dimensionItems, groupOrders, lineHeight, stackItems),\n      height = _stackAll.height,\n      groupHeights = _stackAll.groupHeights,\n      groupTops = _stackAll.groupTops;\n\n  return {\n    dimensionItems: dimensionItems,\n    height: height,\n    groupHeights: groupHeights,\n    groupTops: groupTops\n  };\n}\n/**\n * get canvas width from visible width\n * @param {*} width\n * @param {*} buffer\n */\n\n\nfunction getCanvasWidth(width) {\n  var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  return width * buffer;\n}\n/**\n * get item's position, dimensions and collisions\n * @param {*} item\n * @param {*} keys\n * @param {*} canvasTimeStart\n * @param {*} canvasTimeEnd\n * @param {*} canvasWidth\n * @param {*} groupOrders\n * @param {*} lineHeight\n * @param {*} itemHeightRatio\n */\n\n\nfunction getItemDimensions(_ref3) {\n  var item = _ref3.item,\n      keys = _ref3.keys,\n      canvasTimeStart = _ref3.canvasTimeStart,\n      canvasTimeEnd = _ref3.canvasTimeEnd,\n      canvasWidth = _ref3.canvasWidth,\n      groupOrders = _ref3.groupOrders,\n      lineHeight = _ref3.lineHeight,\n      itemHeightRatio = _ref3.itemHeightRatio;\n  var itemId = (0, _generic._get)(item, keys.itemIdKey);\n  var dimension = calculateDimensions({\n    itemTimeStart: (0, _generic._get)(item, keys.itemTimeStartKey),\n    itemTimeEnd: (0, _generic._get)(item, keys.itemTimeEndKey),\n    canvasTimeStart: canvasTimeStart,\n    canvasTimeEnd: canvasTimeEnd,\n    canvasWidth: canvasWidth\n  });\n\n  if (dimension) {\n    dimension.top = null;\n    dimension.order = groupOrders[(0, _generic._get)(item, keys.itemGroupKey)];\n    dimension.stack = !item.isOverlay;\n    dimension.height = lineHeight * itemHeightRatio;\n    return {\n      id: itemId,\n      dimensions: dimension\n    };\n  }\n}\n/**\n * get new item with changed  `itemTimeStart` , `itemTimeEnd` and `itemGroupKey` according to user interaction\n * user interaction is dragging an item and resize left and right\n * @param {*} item\n * @param {*} keys\n * @param {*} draggingItem\n * @param {*} resizingItem\n * @param {*} dragTime\n * @param {*} resizingEdge\n * @param {*} resizeTime\n * @param {*} groups\n * @param {*} newGroupOrder\n */\n\n\nfunction getItemWithInteractions(_ref4) {\n  var _objectSpread2;\n\n  var item = _ref4.item,\n      keys = _ref4.keys,\n      draggingItem = _ref4.draggingItem,\n      resizingItem = _ref4.resizingItem,\n      dragTime = _ref4.dragTime,\n      resizingEdge = _ref4.resizingEdge,\n      resizeTime = _ref4.resizeTime,\n      groups = _ref4.groups,\n      newGroupOrder = _ref4.newGroupOrder;\n  if (!resizingItem && !draggingItem) return item;\n  var itemId = (0, _generic._get)(item, keys.itemIdKey);\n  var isDragging = itemId === draggingItem;\n  var isResizing = itemId === resizingItem;\n\n  var _calculateInteraction = calculateInteractionNewTimes({\n    itemTimeStart: (0, _generic._get)(item, keys.itemTimeStartKey),\n    itemTimeEnd: (0, _generic._get)(item, keys.itemTimeEndKey),\n    isDragging: isDragging,\n    isResizing: isResizing,\n    dragTime: dragTime,\n    resizingEdge: resizingEdge,\n    resizeTime: resizeTime\n  }),\n      _calculateInteraction2 = _slicedToArray(_calculateInteraction, 2),\n      itemTimeStart = _calculateInteraction2[0],\n      itemTimeEnd = _calculateInteraction2[1];\n\n  var newItem = _objectSpread({}, item, (_objectSpread2 = {}, _defineProperty(_objectSpread2, keys.itemTimeStartKey, itemTimeStart), _defineProperty(_objectSpread2, keys.itemTimeEndKey, itemTimeEnd), _defineProperty(_objectSpread2, keys.itemGroupKey, isDragging ? (0, _generic._get)(groups[newGroupOrder], keys.groupIdKey) : (0, _generic._get)(item, keys.itemGroupKey)), _objectSpread2));\n\n  return newItem;\n}\n/**\n * get canvas start and end time from visible start and end time\n * @param {number} visibleTimeStart\n * @param {number} visibleTimeEnd\n */\n\n\nfunction getCanvasBoundariesFromVisibleTime(visibleTimeStart, visibleTimeEnd) {\n  var zoom = visibleTimeEnd - visibleTimeStart;\n  var canvasTimeStart = visibleTimeStart - (visibleTimeEnd - visibleTimeStart);\n  var canvasTimeEnd = canvasTimeStart + zoom * 3;\n  return [canvasTimeStart, canvasTimeEnd];\n}\n/**\n * Get the the canvas area for a given visible time\n * Will shift the start/end of the canvas if the visible time\n * does not fit within the existing\n * @param {number} visibleTimeStart\n * @param {number} visibleTimeEnd\n * @param {boolean} forceUpdateDimensions\n * @param {*} items\n * @param {*} groups\n * @param {*} props\n * @param {*} state\n */\n\n\nfunction calculateScrollCanvas(visibleTimeStart, visibleTimeEnd, forceUpdateDimensions, items, groups, props, state) {\n  var oldCanvasTimeStart = state.canvasTimeStart;\n  var oldZoom = state.visibleTimeEnd - state.visibleTimeStart;\n  var newZoom = visibleTimeEnd - visibleTimeStart;\n  var newState = {\n    visibleTimeStart: visibleTimeStart,\n    visibleTimeEnd: visibleTimeEnd // Check if the current canvas covers the new times\n\n  };\n  var canKeepCanvas = newZoom === oldZoom && visibleTimeStart >= oldCanvasTimeStart + oldZoom * 0.5 && visibleTimeStart <= oldCanvasTimeStart + oldZoom * 1.5 && visibleTimeEnd >= oldCanvasTimeStart + oldZoom * 1.5 && visibleTimeEnd <= oldCanvasTimeStart + oldZoom * 2.5;\n\n  if (!canKeepCanvas || forceUpdateDimensions) {\n    var _getCanvasBoundariesF = getCanvasBoundariesFromVisibleTime(visibleTimeStart, visibleTimeEnd),\n        _getCanvasBoundariesF2 = _slicedToArray(_getCanvasBoundariesF, 2),\n        canvasTimeStart = _getCanvasBoundariesF2[0],\n        canvasTimeEnd = _getCanvasBoundariesF2[1];\n\n    newState.canvasTimeStart = canvasTimeStart;\n    newState.canvasTimeEnd = canvasTimeEnd;\n\n    var mergedState = _objectSpread({}, state, {}, newState);\n\n    var canvasWidth = getCanvasWidth(mergedState.width); // The canvas cannot be kept, so calculate the new items position\n\n    Object.assign(newState, stackTimelineItems(items, groups, canvasWidth, mergedState.canvasTimeStart, mergedState.canvasTimeEnd, props.keys, props.lineHeight, props.itemHeightRatio, props.stackItems, mergedState.draggingItem, mergedState.resizingItem, mergedState.dragTime, mergedState.resizingEdge, mergedState.resizeTime, mergedState.newGroupOrder));\n  }\n\n  return newState;\n}","map":{"version":3,"sources":["/Users/alexvlk/Documents/Projects/GitHub/ConsultApp/node_modules/react-calendar-timeline/lib/lib/utility/calendar.js"],"names":["Object","defineProperty","exports","value","coordinateToTimeRatio","calculateXPositionForTime","calculateTimeForXPosition","iterateTimes","getMinUnit","getNextUnit","calculateInteractionNewTimes","calculateDimensions","getGroupOrders","getGroupedItems","getVisibleItems","collision","groupStack","groupNoStack","stackAll","stackGroup","stackTimelineItems","getCanvasWidth","getItemDimensions","getItemWithInteractions","getCanvasBoundariesFromVisibleTime","calculateScrollCanvas","minCellWidth","_moment","_interopRequireDefault","require","_generic","obj","__esModule","_objectSpread","target","i","arguments","length","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","defineProperties","getOwnPropertyDescriptors","configurable","writable","_slicedToArray","arr","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","TypeError","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","err","Array","isArray","canvasTimeStart","canvasTimeEnd","canvasWidth","time","widthToZoomRatio","timeOffset","leftOffset","timeToPxRatio","timeFromCanvasTimeStart","start","end","unit","timeSteps","callback","startOf","get","set","valueOf","nextTime","add","zoom","width","timeDividers","second","minute","hour","day","month","year","minUnit","nextTimeSpanInUnitContext","some","cellsToBeRenderedForCurrentUnit","cellWidthToUse","minimumCellsToRenderUnit","nextUnits","Error","_ref","itemTimeStart","itemTimeEnd","dragTime","isDragging","isResizing","resizingEdge","resizeTime","originalItemRange","itemStart","itemEnd","_ref2","itemTimeRange","effectiveStartTime","Math","max","effectiveEndTime","min","left","right","itemWidth","dimensions","collisionLeft","collisionWidth","groups","groupIdKey","groupOrders","_get","index","group","items","groupedItems","groupOrder","order","groupItem","itemTimeStartKey","itemTimeEndKey","item","EPSILON","a","b","lineHeight","collisionPadding","verticalMargin","top","height","groupHeight","groupTop","itemIndex","curHeight","stack","collidingItem","j","jj","other","itemTop","sum","reduce","acc","itemsDimensions","stackItems","groupHeights","groupTops","groupItems","_itemsDimensions","isGroupStacked","_stackGroup","r","itemHeightRatio","draggingItem","resizingItem","newGroupOrder","visibleItems","visibleItemsWithInteraction","map","dimensionItems","_stackAll","buffer","_ref3","itemId","itemIdKey","dimension","itemGroupKey","isOverlay","id","_ref4","_objectSpread2","_calculateInteraction","_calculateInteraction2","newItem","visibleTimeStart","visibleTimeEnd","forceUpdateDimensions","props","state","oldCanvasTimeStart","oldZoom","newZoom","newState","canKeepCanvas","_getCanvasBoundariesF","_getCanvasBoundariesF2","mergedState","assign"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.coordinateToTimeRatio = coordinateToTimeRatio;\nexports.calculateXPositionForTime = calculateXPositionForTime;\nexports.calculateTimeForXPosition = calculateTimeForXPosition;\nexports.iterateTimes = iterateTimes;\nexports.getMinUnit = getMinUnit;\nexports.getNextUnit = getNextUnit;\nexports.calculateInteractionNewTimes = calculateInteractionNewTimes;\nexports.calculateDimensions = calculateDimensions;\nexports.getGroupOrders = getGroupOrders;\nexports.getGroupedItems = getGroupedItems;\nexports.getVisibleItems = getVisibleItems;\nexports.collision = collision;\nexports.groupStack = groupStack;\nexports.groupNoStack = groupNoStack;\nexports.stackAll = stackAll;\nexports.stackGroup = stackGroup;\nexports.stackTimelineItems = stackTimelineItems;\nexports.getCanvasWidth = getCanvasWidth;\nexports.getItemDimensions = getItemDimensions;\nexports.getItemWithInteractions = getItemWithInteractions;\nexports.getCanvasBoundariesFromVisibleTime = getCanvasBoundariesFromVisibleTime;\nexports.calculateScrollCanvas = calculateScrollCanvas;\nexports.minCellWidth = void 0;\n\nvar _moment = _interopRequireDefault(require(\"moment\"));\n\nvar _generic = require(\"./generic\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { if (i % 2) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } else { Object.defineProperties(target, Object.getOwnPropertyDescriptors(arguments[i])); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/**\n * Calculate the ms / pixel ratio of the timeline state\n * @param {number} canvasTimeStart\n * @param {number} canvasTimeEnd\n * @param {number} canvasWidth\n * @returns {number}\n */\nfunction coordinateToTimeRatio(canvasTimeStart, canvasTimeEnd, canvasWidth) {\n  return (canvasTimeEnd - canvasTimeStart) / canvasWidth;\n}\n/**\n * For a given time, calculate the pixel position given timeline state\n * (timeline width in px, canvas time range)\n * @param {number} canvasTimeStart\n * @param {number} canvasTimeEnd\n * @param {number} canvasWidth\n * @param {number} time\n * @returns {number}\n */\n\n\nfunction calculateXPositionForTime(canvasTimeStart, canvasTimeEnd, canvasWidth, time) {\n  var widthToZoomRatio = canvasWidth / (canvasTimeEnd - canvasTimeStart);\n  var timeOffset = time - canvasTimeStart;\n  return timeOffset * widthToZoomRatio;\n}\n/**\n * For a given x position (leftOffset) in pixels, calculate time based on\n * timeline state (timeline width in px, canvas time range)\n * @param {number} canvasTimeStart\n * @param {number} canvasTimeEnd\n * @param {number} canvasWidth\n * @param {number} leftOffset\n * @returns {number}\n */\n\n\nfunction calculateTimeForXPosition(canvasTimeStart, canvasTimeEnd, canvasWidth, leftOffset) {\n  var timeToPxRatio = (canvasTimeEnd - canvasTimeStart) / canvasWidth;\n  var timeFromCanvasTimeStart = timeToPxRatio * leftOffset;\n  return timeFromCanvasTimeStart + canvasTimeStart;\n}\n\nfunction iterateTimes(start, end, unit, timeSteps, callback) {\n  var time = (0, _moment[\"default\"])(start).startOf(unit);\n\n  if (timeSteps[unit] && timeSteps[unit] > 1) {\n    var value = time.get(unit);\n    time.set(unit, value - value % timeSteps[unit]);\n  }\n\n  while (time.valueOf() < end) {\n    var nextTime = (0, _moment[\"default\"])(time).add(timeSteps[unit] || 1, \"\".concat(unit, \"s\"));\n    callback(time, nextTime);\n    time = nextTime;\n  }\n} // this function is VERY HOT as its used in Timeline.js render function\n// TODO: check if there are performance implications here\n// when \"weeks\" feature is implemented, this function will be modified heavily\n\n/** determine the current rendered time unit based on timeline time span\n *\n * zoom: (in milliseconds) difference between time start and time end of timeline canvas\n * width: (in pixels) pixel width of timeline canvas\n * timeSteps: map of timeDividers with number to indicate step of each divider\n */\n// the smallest cell we want to render is 17px\n// this can be manipulated to make the breakpoints change more/less\n// i.e. on zoom how often do we switch to the next unit of time\n// i think this is the distance between cell lines\n\n\nvar minCellWidth = 17;\nexports.minCellWidth = minCellWidth;\n\nfunction getMinUnit(zoom, width, timeSteps) {\n  // for supporting weeks, its important to remember that each of these\n  // units has a natural progression to the other. i.e. a year is 12 months\n  // a month is 24 days, a day is 24 hours.\n  // with weeks this isnt the case so weeks needs to be handled specially\n  var timeDividers = {\n    second: 1000,\n    minute: 60,\n    hour: 60,\n    day: 24,\n    month: 30,\n    year: 12\n  };\n  var minUnit = 'year'; // this timespan is in ms initially\n\n  var nextTimeSpanInUnitContext = zoom;\n  Object.keys(timeDividers).some(function (unit) {\n    // converts previous time span to current unit\n    // (e.g. milliseconds to seconds, seconds to minutes, etc)\n    nextTimeSpanInUnitContext = nextTimeSpanInUnitContext / timeDividers[unit]; // timeSteps is \"\n    // With what step to display different units. E.g. 15 for minute means only minutes 0, 15, 30 and 45 will be shown.\"\n    // how many cells would be rendered given this time span, for this unit?\n    // e.g. for time span of 60 minutes, and time step of 1, we would render 60 cells\n\n    var cellsToBeRenderedForCurrentUnit = nextTimeSpanInUnitContext / timeSteps[unit]; // what is happening here? why 3 if time steps are greater than 1??\n\n    var cellWidthToUse = timeSteps[unit] && timeSteps[unit] > 1 ? 3 * minCellWidth : minCellWidth; // for the minWidth of a cell, how many cells would be rendered given\n    // the current pixel width\n    // i.e. f\n\n    var minimumCellsToRenderUnit = width / cellWidthToUse;\n\n    if (cellsToBeRenderedForCurrentUnit < minimumCellsToRenderUnit) {\n      // for the current zoom, the number of cells we'd need to render all parts of this unit\n      // is less than the minimum number of cells needed at minimum cell width\n      minUnit = unit;\n      return true;\n    }\n  });\n  return minUnit;\n}\n\nfunction getNextUnit(unit) {\n  var nextUnits = {\n    second: 'minute',\n    minute: 'hour',\n    hour: 'day',\n    day: 'month',\n    month: 'year',\n    year: 'year'\n  };\n\n  if (!nextUnits[unit]) {\n    throw new Error(\"unit \".concat(unit, \" in not acceptable\"));\n  }\n\n  return nextUnits[unit];\n}\n/**\n * get the new start and new end time of item that is being\n * dragged or resized\n * @param {*} itemTimeStart original item time in milliseconds\n * @param {*} itemTimeEnd original item time in milliseconds\n * @param {*} dragTime new start time if item is dragged in milliseconds\n * @param {*} isDragging is item being dragged\n * @param {*} isResizing is item being resized\n * @param {`right` or `left`} resizingEdge resize edge\n * @param {*} resizeTime new resize time in milliseconds\n */\n\n\nfunction calculateInteractionNewTimes(_ref) {\n  var itemTimeStart = _ref.itemTimeStart,\n      itemTimeEnd = _ref.itemTimeEnd,\n      dragTime = _ref.dragTime,\n      isDragging = _ref.isDragging,\n      isResizing = _ref.isResizing,\n      resizingEdge = _ref.resizingEdge,\n      resizeTime = _ref.resizeTime;\n  var originalItemRange = itemTimeEnd - itemTimeStart;\n  var itemStart = isResizing && resizingEdge === 'left' ? resizeTime : itemTimeStart;\n  var itemEnd = isResizing && resizingEdge === 'right' ? resizeTime : itemTimeEnd;\n  return [isDragging ? dragTime : itemStart, isDragging ? dragTime + originalItemRange : itemEnd];\n}\n\nfunction calculateDimensions(_ref2) {\n  var itemTimeStart = _ref2.itemTimeStart,\n      itemTimeEnd = _ref2.itemTimeEnd,\n      canvasTimeStart = _ref2.canvasTimeStart,\n      canvasTimeEnd = _ref2.canvasTimeEnd,\n      canvasWidth = _ref2.canvasWidth;\n  var itemTimeRange = itemTimeEnd - itemTimeStart; // restrict startTime and endTime to be bounded by canvasTimeStart and canvasTimeEnd\n\n  var effectiveStartTime = Math.max(itemTimeStart, canvasTimeStart);\n  var effectiveEndTime = Math.min(itemTimeEnd, canvasTimeEnd);\n  var left = calculateXPositionForTime(canvasTimeStart, canvasTimeEnd, canvasWidth, effectiveStartTime);\n  var right = calculateXPositionForTime(canvasTimeStart, canvasTimeEnd, canvasWidth, effectiveEndTime);\n  var itemWidth = right - left;\n  var dimensions = {\n    left: left,\n    width: Math.max(itemWidth, 3),\n    collisionLeft: itemTimeStart,\n    collisionWidth: itemTimeRange\n  };\n  return dimensions;\n}\n/**\n * Get the order of groups based on their keys\n * @param {*} groups array of groups\n * @param {*} keys the keys object\n * @returns Ordered hash of objects with their array index and group\n */\n\n\nfunction getGroupOrders(groups, keys) {\n  var groupIdKey = keys.groupIdKey;\n  var groupOrders = {};\n\n  for (var i = 0; i < groups.length; i++) {\n    groupOrders[(0, _generic._get)(groups[i], groupIdKey)] = {\n      index: i,\n      group: groups[i]\n    };\n  }\n\n  return groupOrders;\n}\n/**\n * Adds items relevant to each group to the result of getGroupOrders\n * @param {*} items list of all items\n * @param {*} groupOrders the result of getGroupOrders\n */\n\n\nfunction getGroupedItems(items, groupOrders) {\n  var groupedItems = {};\n  var keys = Object.keys(groupOrders); // Initialize with result object for each group\n\n  for (var i = 0; i < keys.length; i++) {\n    var groupOrder = groupOrders[keys[i]];\n    groupedItems[i] = {\n      index: groupOrder.index,\n      group: groupOrder.group,\n      items: []\n    };\n  } // Populate groups\n\n\n  for (var _i = 0; _i < items.length; _i++) {\n    if (items[_i].dimensions.order !== undefined) {\n      var groupItem = groupedItems[items[_i].dimensions.order.index];\n\n      if (groupItem) {\n        groupItem.items.push(items[_i]);\n      }\n    }\n  }\n\n  return groupedItems;\n}\n\nfunction getVisibleItems(items, canvasTimeStart, canvasTimeEnd, keys) {\n  var itemTimeStartKey = keys.itemTimeStartKey,\n      itemTimeEndKey = keys.itemTimeEndKey;\n  return items.filter(function (item) {\n    return (0, _generic._get)(item, itemTimeStartKey) <= canvasTimeEnd && (0, _generic._get)(item, itemTimeEndKey) >= canvasTimeStart;\n  });\n}\n\nvar EPSILON = 0.001;\n\nfunction collision(a, b, lineHeight) {\n  var collisionPadding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : EPSILON;\n  // 2d collisions detection - https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection\n  var verticalMargin = 0;\n  return a.collisionLeft + collisionPadding < b.collisionLeft + b.collisionWidth && a.collisionLeft + a.collisionWidth - collisionPadding > b.collisionLeft && a.top - verticalMargin + collisionPadding < b.top + b.height && a.top + a.height + verticalMargin - collisionPadding > b.top;\n}\n/**\n * Calculate the position of a given item for a group that\n * is being stacked\n */\n\n\nfunction groupStack(lineHeight, item, group, groupHeight, groupTop, itemIndex) {\n  // calculate non-overlapping positions\n  var curHeight = groupHeight;\n  var verticalMargin = (lineHeight - item.dimensions.height) / 2;\n\n  if (item.dimensions.stack && item.dimensions.top === null) {\n    item.dimensions.top = groupTop + verticalMargin;\n    curHeight = Math.max(curHeight, lineHeight);\n\n    do {\n      var collidingItem = null; //Items are placed from i=0 onwards, only check items with index < i\n\n      for (var j = itemIndex - 1, jj = 0; j >= jj; j--) {\n        var other = group[j];\n\n        if (other.dimensions.top !== null && other.dimensions.stack && collision(item.dimensions, other.dimensions, lineHeight)) {\n          collidingItem = other;\n          break;\n        } else {// console.log('dont test', other.top !== null, other !== item, other.stack);\n        }\n      }\n\n      if (collidingItem != null) {\n        // There is a collision. Reposition the items above the colliding element\n        item.dimensions.top = collidingItem.dimensions.top + lineHeight;\n        curHeight = Math.max(curHeight, item.dimensions.top + item.dimensions.height + verticalMargin - groupTop);\n      }\n    } while (collidingItem);\n  }\n\n  return {\n    groupHeight: curHeight,\n    verticalMargin: verticalMargin,\n    itemTop: item.dimensions.top\n  };\n} // Calculate the position of this item for a group that is not being stacked\n\n\nfunction groupNoStack(lineHeight, item, groupHeight, groupTop) {\n  var verticalMargin = (lineHeight - item.dimensions.height) / 2;\n\n  if (item.dimensions.top === null) {\n    item.dimensions.top = groupTop + verticalMargin;\n    groupHeight = Math.max(groupHeight, lineHeight);\n  }\n\n  return {\n    groupHeight: groupHeight,\n    verticalMargin: 0,\n    itemTop: item.dimensions.top\n  };\n}\n\nfunction sum() {\n  var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return arr.reduce(function (acc, i) {\n    return acc + i;\n  }, 0);\n}\n/**\n * Stack all groups\n * @param {*} items items to be stacked\n * @param {*} groupOrders the groupOrders object\n * @param {*} lineHeight\n * @param {*} stackItems should items be stacked?\n */\n\n\nfunction stackAll(itemsDimensions, groupOrders, lineHeight, stackItems) {\n  var groupHeights = [];\n  var groupTops = [];\n  var groupedItems = getGroupedItems(itemsDimensions, groupOrders);\n\n  for (var index in groupedItems) {\n    var groupItems = groupedItems[index];\n    var _itemsDimensions = groupItems.items,\n        group = groupItems.group;\n    var groupTop = sum(groupHeights); // Is group being stacked?\n\n    var isGroupStacked = group.stackItems !== undefined ? group.stackItems : stackItems;\n\n    var _stackGroup = stackGroup(_itemsDimensions, isGroupStacked, lineHeight, groupTop),\n        groupHeight = _stackGroup.groupHeight,\n        verticalMargin = _stackGroup.verticalMargin; // If group height is overridden, push new height\n    // Do this late as item position still needs to be calculated\n\n\n    groupTops.push(groupTop);\n\n    if (group.height) {\n      groupHeights.push(group.height);\n    } else {\n      groupHeights.push(Math.max(groupHeight, lineHeight));\n    }\n  }\n\n  return {\n    height: sum(groupHeights),\n    groupHeights: groupHeights,\n    groupTops: groupTops\n  };\n}\n/**\n * \n * @param {*} itemsDimensions \n * @param {*} isGroupStacked \n * @param {*} lineHeight \n * @param {*} groupTop \n */\n\n\nfunction stackGroup(itemsDimensions, isGroupStacked, lineHeight, groupTop) {\n  var groupHeight = 0;\n  var verticalMargin = 0; // Find positions for each item in group\n\n  for (var itemIndex = 0; itemIndex < itemsDimensions.length; itemIndex++) {\n    var r = {};\n\n    if (isGroupStacked) {\n      r = groupStack(lineHeight, itemsDimensions[itemIndex], itemsDimensions, groupHeight, groupTop, itemIndex);\n    } else {\n      r = groupNoStack(lineHeight, itemsDimensions[itemIndex], groupHeight, groupTop);\n    }\n\n    groupHeight = r.groupHeight;\n    verticalMargin = r.verticalMargin;\n  }\n\n  return {\n    groupHeight: groupHeight,\n    verticalMargin: verticalMargin\n  };\n}\n/**\n * Stack the items that will be visible\n * within the canvas area\n * @param {item[]} items\n * @param {group[]} groups\n * @param {number} canvasWidth\n * @param {number} canvasTimeStart\n * @param {number} canvasTimeEnd\n * @param {*} keys\n * @param {number} lineHeight\n * @param {number} itemHeightRatio\n * @param {boolean} stackItems\n * @param {*} draggingItem\n * @param {*} resizingItem\n * @param {number} dragTime\n * @param {left or right} resizingEdge\n * @param {number} resizeTime\n * @param {number} newGroupOrder\n */\n\n\nfunction stackTimelineItems(items, groups, canvasWidth, canvasTimeStart, canvasTimeEnd, keys, lineHeight, itemHeightRatio, stackItems, draggingItem, resizingItem, dragTime, resizingEdge, resizeTime, newGroupOrder) {\n  var visibleItems = getVisibleItems(items, canvasTimeStart, canvasTimeEnd, keys);\n  var visibleItemsWithInteraction = visibleItems.map(function (item) {\n    return getItemWithInteractions({\n      item: item,\n      keys: keys,\n      draggingItem: draggingItem,\n      resizingItem: resizingItem,\n      dragTime: dragTime,\n      resizingEdge: resizingEdge,\n      resizeTime: resizeTime,\n      groups: groups,\n      newGroupOrder: newGroupOrder\n    });\n  }); // if there are no groups return an empty array of dimensions\n\n  if (groups.length === 0) {\n    return {\n      dimensionItems: [],\n      height: 0,\n      groupHeights: [],\n      groupTops: []\n    };\n  } // Get the order of groups based on their id key\n\n\n  var groupOrders = getGroupOrders(groups, keys);\n  var dimensionItems = visibleItemsWithInteraction.map(function (item) {\n    return getItemDimensions({\n      item: item,\n      keys: keys,\n      canvasTimeStart: canvasTimeStart,\n      canvasTimeEnd: canvasTimeEnd,\n      canvasWidth: canvasWidth,\n      groupOrders: groupOrders,\n      lineHeight: lineHeight,\n      itemHeightRatio: itemHeightRatio\n    });\n  }).filter(function (item) {\n    return !!item;\n  }); // Get a new array of groupOrders holding the stacked items\n\n  var _stackAll = stackAll(dimensionItems, groupOrders, lineHeight, stackItems),\n      height = _stackAll.height,\n      groupHeights = _stackAll.groupHeights,\n      groupTops = _stackAll.groupTops;\n\n  return {\n    dimensionItems: dimensionItems,\n    height: height,\n    groupHeights: groupHeights,\n    groupTops: groupTops\n  };\n}\n/**\n * get canvas width from visible width\n * @param {*} width\n * @param {*} buffer\n */\n\n\nfunction getCanvasWidth(width) {\n  var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n  return width * buffer;\n}\n/**\n * get item's position, dimensions and collisions\n * @param {*} item\n * @param {*} keys\n * @param {*} canvasTimeStart\n * @param {*} canvasTimeEnd\n * @param {*} canvasWidth\n * @param {*} groupOrders\n * @param {*} lineHeight\n * @param {*} itemHeightRatio\n */\n\n\nfunction getItemDimensions(_ref3) {\n  var item = _ref3.item,\n      keys = _ref3.keys,\n      canvasTimeStart = _ref3.canvasTimeStart,\n      canvasTimeEnd = _ref3.canvasTimeEnd,\n      canvasWidth = _ref3.canvasWidth,\n      groupOrders = _ref3.groupOrders,\n      lineHeight = _ref3.lineHeight,\n      itemHeightRatio = _ref3.itemHeightRatio;\n  var itemId = (0, _generic._get)(item, keys.itemIdKey);\n  var dimension = calculateDimensions({\n    itemTimeStart: (0, _generic._get)(item, keys.itemTimeStartKey),\n    itemTimeEnd: (0, _generic._get)(item, keys.itemTimeEndKey),\n    canvasTimeStart: canvasTimeStart,\n    canvasTimeEnd: canvasTimeEnd,\n    canvasWidth: canvasWidth\n  });\n\n  if (dimension) {\n    dimension.top = null;\n    dimension.order = groupOrders[(0, _generic._get)(item, keys.itemGroupKey)];\n    dimension.stack = !item.isOverlay;\n    dimension.height = lineHeight * itemHeightRatio;\n    return {\n      id: itemId,\n      dimensions: dimension\n    };\n  }\n}\n/**\n * get new item with changed  `itemTimeStart` , `itemTimeEnd` and `itemGroupKey` according to user interaction\n * user interaction is dragging an item and resize left and right\n * @param {*} item\n * @param {*} keys\n * @param {*} draggingItem\n * @param {*} resizingItem\n * @param {*} dragTime\n * @param {*} resizingEdge\n * @param {*} resizeTime\n * @param {*} groups\n * @param {*} newGroupOrder\n */\n\n\nfunction getItemWithInteractions(_ref4) {\n  var _objectSpread2;\n\n  var item = _ref4.item,\n      keys = _ref4.keys,\n      draggingItem = _ref4.draggingItem,\n      resizingItem = _ref4.resizingItem,\n      dragTime = _ref4.dragTime,\n      resizingEdge = _ref4.resizingEdge,\n      resizeTime = _ref4.resizeTime,\n      groups = _ref4.groups,\n      newGroupOrder = _ref4.newGroupOrder;\n  if (!resizingItem && !draggingItem) return item;\n  var itemId = (0, _generic._get)(item, keys.itemIdKey);\n  var isDragging = itemId === draggingItem;\n  var isResizing = itemId === resizingItem;\n\n  var _calculateInteraction = calculateInteractionNewTimes({\n    itemTimeStart: (0, _generic._get)(item, keys.itemTimeStartKey),\n    itemTimeEnd: (0, _generic._get)(item, keys.itemTimeEndKey),\n    isDragging: isDragging,\n    isResizing: isResizing,\n    dragTime: dragTime,\n    resizingEdge: resizingEdge,\n    resizeTime: resizeTime\n  }),\n      _calculateInteraction2 = _slicedToArray(_calculateInteraction, 2),\n      itemTimeStart = _calculateInteraction2[0],\n      itemTimeEnd = _calculateInteraction2[1];\n\n  var newItem = _objectSpread({}, item, (_objectSpread2 = {}, _defineProperty(_objectSpread2, keys.itemTimeStartKey, itemTimeStart), _defineProperty(_objectSpread2, keys.itemTimeEndKey, itemTimeEnd), _defineProperty(_objectSpread2, keys.itemGroupKey, isDragging ? (0, _generic._get)(groups[newGroupOrder], keys.groupIdKey) : (0, _generic._get)(item, keys.itemGroupKey)), _objectSpread2));\n\n  return newItem;\n}\n/**\n * get canvas start and end time from visible start and end time\n * @param {number} visibleTimeStart\n * @param {number} visibleTimeEnd\n */\n\n\nfunction getCanvasBoundariesFromVisibleTime(visibleTimeStart, visibleTimeEnd) {\n  var zoom = visibleTimeEnd - visibleTimeStart;\n  var canvasTimeStart = visibleTimeStart - (visibleTimeEnd - visibleTimeStart);\n  var canvasTimeEnd = canvasTimeStart + zoom * 3;\n  return [canvasTimeStart, canvasTimeEnd];\n}\n/**\n * Get the the canvas area for a given visible time\n * Will shift the start/end of the canvas if the visible time\n * does not fit within the existing\n * @param {number} visibleTimeStart\n * @param {number} visibleTimeEnd\n * @param {boolean} forceUpdateDimensions\n * @param {*} items\n * @param {*} groups\n * @param {*} props\n * @param {*} state\n */\n\n\nfunction calculateScrollCanvas(visibleTimeStart, visibleTimeEnd, forceUpdateDimensions, items, groups, props, state) {\n  var oldCanvasTimeStart = state.canvasTimeStart;\n  var oldZoom = state.visibleTimeEnd - state.visibleTimeStart;\n  var newZoom = visibleTimeEnd - visibleTimeStart;\n  var newState = {\n    visibleTimeStart: visibleTimeStart,\n    visibleTimeEnd: visibleTimeEnd // Check if the current canvas covers the new times\n\n  };\n  var canKeepCanvas = newZoom === oldZoom && visibleTimeStart >= oldCanvasTimeStart + oldZoom * 0.5 && visibleTimeStart <= oldCanvasTimeStart + oldZoom * 1.5 && visibleTimeEnd >= oldCanvasTimeStart + oldZoom * 1.5 && visibleTimeEnd <= oldCanvasTimeStart + oldZoom * 2.5;\n\n  if (!canKeepCanvas || forceUpdateDimensions) {\n    var _getCanvasBoundariesF = getCanvasBoundariesFromVisibleTime(visibleTimeStart, visibleTimeEnd),\n        _getCanvasBoundariesF2 = _slicedToArray(_getCanvasBoundariesF, 2),\n        canvasTimeStart = _getCanvasBoundariesF2[0],\n        canvasTimeEnd = _getCanvasBoundariesF2[1];\n\n    newState.canvasTimeStart = canvasTimeStart;\n    newState.canvasTimeEnd = canvasTimeEnd;\n\n    var mergedState = _objectSpread({}, state, {}, newState);\n\n    var canvasWidth = getCanvasWidth(mergedState.width); // The canvas cannot be kept, so calculate the new items position\n\n    Object.assign(newState, stackTimelineItems(items, groups, canvasWidth, mergedState.canvasTimeStart, mergedState.canvasTimeEnd, props.keys, props.lineHeight, props.itemHeightRatio, props.stackItems, mergedState.draggingItem, mergedState.resizingItem, mergedState.dragTime, mergedState.resizingEdge, mergedState.resizeTime, mergedState.newGroupOrder));\n  }\n\n  return newState;\n}"]},"metadata":{},"sourceType":"script"}